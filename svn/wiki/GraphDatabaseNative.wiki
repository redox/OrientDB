#summary Graph Database with Native implementation
#labels GraphDB,Java,api

<wiki:toc max_depth="4" />

= Introduction =

_NOTE: This API will be deprecated soon. Use [GraphDatabaseRaw] or [GraphDatabaseTinkerpop]._

OrientDB provides natively the class [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/db/graph/ODatabaseGraphTx.java ODatabaseGraphTx] to handle graphs in easy way. Furthermore, starting from v. 0.9.22, OrientDB provides an implementation of the [GraphDatabaseTinkerpop Tinkerpop stack]. You can use both APIs together.

Main graph classes:
 * [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/db/graph/ODatabaseGraphTx.java ODatabaseGraphTx]: Main class to handle graphs
 * [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/db/graph/OGraphVertex.java OGraphVertex]: the *Vertex* implementation
 * [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/db/graph/OGraphEdge.java OGraphEdge]: the *Edge* implementation

= First example =

== Create an empty database ==
Launch the [ConsoleCommands console] and type:
{{{
> create database local:C:/temp/graph/graph admin admin local
}}}

_If you're using Linux, MacOsX or any other Operative System change the location of the database to adhere to its file system._

== Create a graph of 1,000 vertexes ==
This example creates a graph of 1,000 vertex. The root node will be bound to the database to get accessed for further uses (such as read). The graph has only one edge, so the deep level is of 1,000!
{{{
ODatabaseGraphTx database = new ODatabaseGraphTx("local:C:/temp/graph/graph");
database.open("admin", "admin");

OGraphVertex rootNode = database.createVertex().set("id", 0);
OGraphVertex currentNode = rootNode;

for (int i = 1; i < 1000; ++i) {
  OGraphVertex newNode = database.createVertex().set("id", i);
  currentNode.link(newNode);
  currentNode = newNode;
}
database.setRoot("graph", rootNode);

database.close();
}}}

The main points of the code above are:
 * {{{database.createVertex()}}}: creates a new vertex
 * {{{database.createVertex().set("id", 0)}}}: set the property "id" to the value 0 to the new created vertex object
 * {{{currentNode.link(newNode)}}}: links the current node to the new one. OrientDB creates a new edge between them
 * {{{database.setRoot("graph", rootNode)}}}: set the root vertex as a root node called "graph"

== Browse the entire graph ==
{{{
public static void main(String[] args) {
  ODatabaseGraphTx database = new ODatabaseGraphTx("local:C:/temp/graph/graph");
  database.open("admin", "admin");

  OGraphVertex rootNode = database.getRoot("graph");

  readAllTheGraph( rootNode );

  database.setRoot("graph", rootNode);
}

private void readAllTheGraph(final OGraphVertex iNode) {
  for (OGraphVertex node : iNode.browseEdgeDestinations()) {
    readAllTheGraph(node);
  }
}
}}}

The main points of the code above are:
 * {{{database.getRoot("graph")}}}: get the root vertex by name ("graph")
 * {{{iNode.browseEdgeDestinations()}}}: browse all the edge destinations as the "destination" of each edge

= Build the graph =
To build a graph you have to create vertexes and connect them with edges.

== Create vertexes ==
To create a new vertex:
{{{
OGraphVertex vertex = new OGraphVertex(db);
vertex.set("type", "TV");
vertex.set("brand", "Samsung");
vertex.save();
}}}

To make the graph elements persistent, remember to call always the save() method against the new vertex.

== Create edges ==
Use the {{{OGraphVertex.link( otherVertex )}}} to create a new edge between two vertexes. Use the method {{{OGraphVertex.link( otherVertex, class )}}} to specify also the class name of the edge to use. Example:
{{{
OGraphVertex vertex1 = new OGraphVertex(db);
vertex1.set("name", "Jay");
vertex1.set("surname", "Miner");

OGraphVertex vertex2 = new OGraphVertex(db);
vertex2.set("name", "Amiga");
vertex2.set("type", "Computer");

OGraphEdge edge = vertex1.link( vertex2 );
edge.set("on", "1985");
edge.save();
}}}

Remember to call the save() method against the new edge or any of the vertexes connected. save() is viral and save recursively all the dirty elements.

== Remove edges ==
Use the {{{OGraphVertex.unlink( otherVertex )}}} to remove an edge between two vertexes.

== Delete vertexes ==
On {{{OGraphVertex.delete()}}} method all the edges are unlinked before to delete the vertex. This assure the graph remains coherent.

= Query vertexes =
OrientDB comes with a powerful query language based on SQL but with several extensions for graphs.

== Query targets ==
Query can start from one or multiple root nodes. In SQL the queries can have as target only tables. In OrientDB you can use:
 * the entire [Concepts#Class Class] (the closest concept to a Relational Table). Example: {{{SELECT FROM OGraphVertex WHERE name = 'test'}}}
 * the entire [Concepts#Cluster Cluster] (the physical place where records reside). Example: {{{select from cluster:OGraphVertex WHERE outEdges.size() > 0}}}
 * a single [Concepts#RecordID RID]. Example: {{{select from 11:4 where any() traverse(0,10) (@class='Profile' && address.city = 'Rome')}}}
 * multiple [Concepts#RecordID RID]s. Example: {{{select from [11:0,11:1,11:2] where outEdge.size() > 0}}}

== Traverse operator ==
OrientDB allows to traverse all or part of the graph starting from a set of *Vertexes*. The syntax is:
{{{
SELECT FROM <target> WHERE <field> TRAVERSE[(<minDeep> [,<maxDeep> [,<fields>]])] (<conditions>)
}}}

Where:
 * *target* can be one of [#Query_target listed above]
 * *field* can be:
  * *outEdges*, as the outgoing edges
  * *inEdges*, as the incoming edges
  * *any attribute of the vertex*
  * *any()*, means any of the field considering also *inEdges* and *outEdges*
  * *all()*, means all the fields considering also *inEdges* and *outEdges*
 * *minDeep* is the minimum deep level to start to apply the conditions. Usually is 0 for the root vertex or 1 for the just-outgoing vertexes
 * *maxDeep*, optionally limits the maximum deep level to reach. -1 means infinite. Default is -1
 * *fields*, optionally tells the field list to traverse. Default is any()
 * *conditions* are the conditions to check for any traversed vertex. To know more about the query syntax see [http://code.google.com/p/orient/wiki/SQLWhere SQL syntax]

=== Examples ===
Returns the record with id "11:4" if traversing all its connections, up to the 10th level, there is a profile that lives in Rome:

{{{select from 11:4 where any() traverse(0,10) (@class='Profile' && address.city = 'Rome') }}}

= Polymorphism and custom types =

OrientDB supports the polymorphism with vertex and edges. You can create your own Vertex and Edge types using the Object Oriented paradigm.

All the vertex types must inherit the *OGraphVertex* at the highest point of the inheritance chain. The same is for edge types but the class to inherit is *OGraphEdge*.
When you extends classes (or types, is the same concepts) you inherit all the fields and constraints of the extended class. Furthermore you can use the OrientDB query engine to execute polymorphic queries (see later).

Example of class inheritance schema:
{{{
           OGraphVertex
                |
             Vehicle
                |
               / \
              /   \
            Car  Motocycle
}}}

This is the simple code that creates the classes:
{{{
  OClass vehicleClass = database.getMetadata().getSchema().createClass("GraphVehicle").setSuperClass(database.getMetadata().getSchema().getClass(OGraphVertex.class));

  database.getMetadata().getSchema().createClass("GraphCar").setSuperClass(vehicleClass);
  database.getMetadata().getSchema().createClass("GraphMotocycle").setSuperClass(vehicleClass);
  database.getMetadata().getSchema().save();
}}}

Create vertexes of custom type:
{{{
  OGraphVertex carNode = database.createVertex("GraphCar").set("brand", "Hyundai").set("model", "Coupe").set("year", 2003).save();
  OGraphVertex motoNode = database.createVertex("GraphMotocycle").set("brand", "Yamaha").set("model", "X-City 250").set("year", 2009).save();
}}}

Execute polymorphic queries against custom types:
{{{
  List<OGraphVertex> result = database.query(new OSQLSynchQuery<OGraphVertex>("select from GraphVehicle"));
  Assert.assertEquals(result.size(), 2);
  for (OGraphVertex v : result) {
    Assert.assertTrue(v.getDocument().getSchemaClass().isSubClassOf(vehicleClass));
  }

  database.close();
}}}