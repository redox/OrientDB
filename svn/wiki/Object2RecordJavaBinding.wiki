#summary Object to Record mapping
#labels Java,API

<wiki:toc max_depth="4" />

= Introduction =
The ObjectDatabase implementation makes things easier for the Java developer since the binding between Objects to Records is transparentr.

== How it works? ==

OrientDB uses Java reflection and doesn't require that the POJO is enhanced in order to use it according to the [http://java.sun.com/jdo JDO standard] and doesn't use Proxies as do many [http://java.sun.com/developer/technicalArticles/J2EE/jpa JPA] implementations such as [http://www.hibernate.org Hibernate]. So how can you work with plain POJOs?

OrientDB works in two ways:
 * Connected mode
 * Detached mode

== Connected mode ==

The [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/db/object/ODatabaseObjectTx.java ODatabaseObjectTx] implementation is the gateway between the developer and OrientDB. [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/db/object/ODatabaseObjectTx.java ODatabaseObjectTx] keeps track of the relationship between the POJO and the Record.

Each POJO read from the database is created and tracked by [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/db/object/ODatabaseObjectTx.java ODatabaseObjectTx]. If you change the POJO and call the {{{ODatabaseObjectTx.save(pojo)}}} method, OrientDB recognizes the POJO bound with the underlying record and, before saving it, will copy the POJO attributes to the loaded record.

This works with POJOs that belong to the same [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/db/object/ODatabaseObjectTx.java ODatabaseObjectTx] instance. For example:

{{{
ODatabaseObjectTx db = new ODatabaseObjectTx("remote:localhost/demo");
db.open("admin", "admin");

try{
  List<Customer> result = db.query( new OSQLSynchQuery<Customer>(db, "select from customer") );
  for( Customer c : result ){
    c.setAge( 100 );
    db.save( c ); // <- AT THIS POINT THE POJO WILL BE RECOGNIZED AS KNOWN BECAUSE IS
                 // ALWAYS LOADED WITH THIS DB INSTANCE
  }

} finally {
  db.close;
}
}}}


When the {{{db.save( c )}}} is called, the [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/db/object/ODatabaseObjectTx.java ODatabaseObjectTx] instance already knows obout it because has been retrieved by using a query through the same instance.

== Detached mode ==

In a typical Front-End application you need to load objects, display them to the user, capture the changes and save them back to the database. Usually this is implemented by using a database pool in order to avoid leaving a database instance open for the entire life cycle of the user session.

The database pool manages a configurable number of database instances. These instances are recycled for all database operations, so the list of connected POJOs is cleared at every release of the database pool instance. This is why the database instance doesn't know the POJO used by the application and in this mode if you save a previously loaded POJO it will appear as a NEW one and is therefore created as new instance in the database with a new [Concepts#RecordID RecordID].

This is why OrientDB needs to store the record information inside the POJO itself. This is retrieved when the POJO is saved so it is known if the POJO already has own identity (has been previously loaded) or not (it's new).

To save the [Concepts#RecordID Record Identity] you can use the [http://java.sun.com/developer/technicalArticles/J2EE/jpa JPA] *[http://download.oracle.com/javaee/5/api/javax/persistence/Id.html @Id]* annotation above the property interested. You can declare it as:
 * *Object*, the suggested, in this case OrientDB will store the ORecordId instance
 * *String*, in this case OrientDB will store the string representation of the ORecordId
 * *Long*, in this case OrientDB will store the right part of the [Concepts#RecordID RecordID]. This works only if you've a schema for the class. The left side will be rebuilt at save time by getting the class id.

Example:

{{{
public class Customer{
  @Id
  private Object id; // DON'T CREATE GETTER/SETTER FOR IT TO PREVENT THE CHANGING BY THE USER APPLICATION, 
                  // UNLESS IT'S NEEDED

  private String name;
  private String surname;

  public String getName(){
    return name;
  }
  public void setName(String name){
    this.name = name;
  }

  public String getSurname(){
    return name;
  }
  public void setSurname(String surname){
    this.surname = surname;
  }
}
}}}

OrientDB will save the [Concepts#RecordID Record Identity] in the *id* property even if getter/setter methods are not created.

If you work with transactions you also need to store the Record Version in the POJO to allow MVCC. Use the [http://java.sun.com/developer/technicalArticles/J2EE/jpa JPA] *[http://download.oracle.com/javaee/5/api/javax/persistence/Version.html @Version]* annotation above the property interested. You can declare it as:
 * *Object* or *Integer*, the suggested, in this case OrientDB will store the version using a java.lang.Integer type
 * *String*, in this case OrientDB will store the string representation of the version

Example:

{{{
public class Customer{
  @Id
  private Object id; // DON'T CREATE GETTER/SETTER FOR IT TO PREVENT THE CHANGING BY THE USER APPLICATION, 
                  // UNLESS IT'S NEEDED

  @Version
  private Object version; // DON'T CREATE GETTER/SETTER FOR IT TO PREVENT THE CHANGING BY THE USER APPLICATION, 
                       // UNLESS IT'S NEEDED

  private String name;
  private String surname;

  public String getName(){
    return name;
  }
  public void setName(String name){
    this.name = name;
  }

  public String getSurname(){
    return name;
  }
  public void setSurname(String surname){
    this.surname = surname;
  }
}
}}}

== Save Mode ==
Since OrientDB doesn't know what object is changed in a tree of connected objects, by default it saves all the objects. This could be very expensive for big trees. This is the reason why you can control manually what is changed or not via a setting in the ODatabaseObjectTx instance:

{{{
db.setSaveOnlyDirty(true);
}}}

or by setting a global parameter (see [http://code.google.com/p/orient/wiki/PerformanceTuning#Parameters Parameters]):
{{{
OGlobalConfiguration.OBJECT_SAVE_ONLY_DIRTY.setValue(true);
}}}

To track what object is dirty use:
{{{
db.setDirty(pojo);
}}}

To unset the dirty status of an object use:
{{{
db.unsetDirty(pojo);
}}}

Dirty mode doesn't affect in memory state of POJOs, so if you change an object without marking it as dirty, OrientDB doesn't know that the object is changed. Furthermore if you load the same changed object using the same database instance, the modified object is returned.

= Requirements =
== Declare persistent classes ==
In order to know which classes are persistent (between thousands in your classpath), you need to tell OrientDB. Using the Java API is:
{{{
database.getEntityManager().registerEntityClasses("com.orientechnologies.orient.test.domain");
}}}

OrientDB saves only the final part of the class name without the package. For example if you're using the class {{{Account}}} in the package {{{com.orientechnologies.demo}}}, the persistent class will be only "Account" and not the entire {{{com.orientechnologies.demo.Account}}}. This means that class names, in the database, are always unique and can't exist two class with the same name even if declared in different packages.

== Empty constructor ==
All your classes must have an empty constructor to let to OrientDB to create instances.

= POJO binding =
All the POJO attributes will be read/stored from/into the record except for fields with the _transient_ modifier. OrientDB uses Java reflection but the discovery of POJO classes is made only the first time at startup. Java Reflection information is inspected only the first time to speed up the access to the fields/methods.

There are 2 kinds of binding: 
 * Default binding and
 * Raw binding

== Default binding ==
This is the default. It tries to use the getter and setter methods for the field if they exist, otherwise goes in RAW mode (see below). The convention for the getter is the same as Java: {{{get<field-name>}}} where field-name is capitalized. The same is for setter but with 'set' as prefix instead of 'get': {{{set<field-name>}}}. If the getter or setter is missing, then the raw binding will be used.

Example:
Field '{{{String name}}}' -> {{{getName()}}} and {{{setName(String)}}}

== Raw binding ==
This mode acts at raw level by accessing the field directly. If the field signature is *private* or *protected*, then the accessibility will be forced. This works generally in all the scenarios except where a custom SecurityManager is defined that denies the change to the accessibility of the field.

To force this behaviour, use the [http://java.sun.com/developer/technicalArticles/J2EE/jpa JPA 2] *[http://download.oracle.com/javaee/6/api/javax/persistence/AccessType.html @AccessType]* annotation above the relevant property. For example:

{{{
public class Customer{
  @AccessType(FIELD)
  private String name;

  private String surname;

  public String getSurname(){
    return name;
  }
  public void setSurname(String surname){
    this.surname = surname;
  }
}
}}}

= Read a POJO =
You can read a POJO from the database in two ways:
- by calling the method {{{load(ORID)}}}
- by executing a query {{{query(q)}}}

When OrientDB loads the record, it creates a new POJO by calling the empty constructor and filling all the fields available in the source record. If a field is present only in the record and not in the POJO class, then it will be ignored. Even when the POJO is updated, any fields in the record that are not available in the POJO class will be untouched.

== Callbacks ==
You can define some methods in the POJO class that are called as callbacks before the record is read:
 * [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/annotation/OBeforeDeserialization.java @OBeforeDeserialization] called just BEFORE unmarshalling the object from the source record
 * [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/annotation/OAfterDeserialization.java @OAfterDeserialization] called just AFTER unmarshalling the object from the source record

Example:
{{{
public class Account{
  private String name;
  transient private String status;

  @OAfterDeserialization
  public void init(){
    status = "Loaded";
  }
}
}}}

Callbacks are useful to initialize transient fields.

= Save a POJO =
You can save a POJO to the database by calling the method {{{save(pojo)}}}. If the POJO is already known to the [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/db/object/ODatabaseObjectTx.java ODatabaseObjectTx] instance, then it updates the underlying record by copying all the POJO attributes to the records (omitting those with _transient_ modifier).

== Callbacks ==
You can define in the POJO class some methods called as callback before the record is written:
 * [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/annotation/OBeforeSerialization.java @OBeforeSerialization] called just BEFORE marshalling the object to the record
 * [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/annotation/OAfterSerialization.java @OAfterSerialization] called just AFTER marshalling the object to the record

Example:
{{{
public class Account{
  private String name;
  transient private Socket s;

  @OAfterSerialization
  public void free(){
    s.close();
  }
}
}}}

Callbacks are useful to free transient resources.

= Fetching strategies =

Starting from release 0.9.20, OrientDB supports [FetchingStrategies Fetching strategies] by using the *Fetch Plans*. Fetch Plans are used to customize how OrientDB must load linked records. The [http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/db/object/ODatabaseObjectTx.java ODatabaseObjectTx] uses the Fetch Plan also to determine how to bind the linked records to the POJO by building an object tree.